{"version":3,"sources":["components/Header.js","components/Counter.js","components/Player.js","components/App.js","serviceWorker.js","index.js"],"names":["Header","props","title","className","totalPlayers","Counter","index","onClick","changeScore","score","Player","removePlayer","id","name","App","state","players","handleScoreChange","delta","setState","prevState","handleRemovePlayer","filter","player","this","length","map","key","toString","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"wOAuBeA,G,MAlBA,SAACC,GAEZ,OAEI,gCAKI,4BAAMA,EAAMC,OACZ,0BAAMC,UAAU,SAAhB,YAAmCF,EAAMG,aAAzC,QCmIGC,EAfS,SAACJ,GACjB,IAAIK,EAAQL,EAAMK,MAClB,OACI,yBAAKH,UAAU,WAKX,4BAAQA,UAAU,2BAA2BI,QAAS,kBAAMN,EAAMO,YAAYF,GAAQ,KAAtF,KACA,0BAAMH,UAAU,iBAAkBF,EAAMQ,OACxC,4BAAQN,UAAU,2BAA2BI,QAAS,kBAAKN,EAAMO,YAAYF,EAAO,KAApF,OC9GDI,EA5BA,SAACT,GAEZ,OACI,yBAAKE,UAAU,UACX,0BAAMA,UAAU,eACZ,4BAAQA,UAAU,gBAAgBI,QAAU,kBAAMN,EAAMU,aAAaV,EAAMW,MAA3E,UACCX,EAAMY,MAGX,kBAAC,EAAD,CACAJ,MAAOR,EAAMQ,MACbH,MAAOL,EAAMK,MACbE,YAAaP,EAAMO,gBCqGhBM,E,4MAnGbC,MAAQ,CACNC,QAAS,CACP,CACEH,KAAM,MACNJ,MAAM,EACNG,GAAI,GAER,CACIC,KAAM,SACNJ,MAAM,EACNG,GAAI,GAER,CACIC,KAAM,QACNJ,MAAM,EACNG,GAAI,GAER,CACIC,KAAM,QACNJ,MAAM,EACNG,GAAI,K,EAIVK,kBAAoB,SAACX,EAAOY,GAKxB,EAAKC,UAAS,SAAAC,GAEZ,MAAO,CACLX,MAAOW,EAAUJ,QAAQV,GAAOG,OAASS,O,EAMjDG,mBAAqB,SAACT,GAEpB,EAAKO,UAAS,SAAAC,GAGZ,MAAO,CACLJ,QAASI,EAAUJ,QAAQM,QAAO,SAACC,GACjC,OAAOA,EAAOX,KAAOA,U,uDASnB,IAAD,OACP,OACE,yBAAKT,UAAU,cAEX,kBAAC,EAAD,CACQD,MAAM,aACNE,aAAcoB,KAAKT,MAAMC,QAAQS,SAenCD,KAAKT,MAAMC,QAAQU,KAAK,SAACH,EAAQjB,GAAT,OACtB,kBAAC,EAAD,CACIO,KAAMU,EAAOV,KACbJ,MAAOc,EAAOd,MACdG,GAAIW,EAAOX,GACXe,IAAKJ,EAAOX,GAAGgB,WACftB,MAAOA,EACPE,YAAa,EAAKS,kBAClBN,aAAc,EAAKU,6B,GA/FvBQ,aCOEC,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCWNC,IAASC,OACL,kBAAC,EAAD,MAEFC,SAASC,eAAe,SDmGpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,a","file":"static/js/main.908cd040.chunk.js","sourcesContent":["import React from 'react';\n\n// define the component as arrow function\n// When you define a component using a function, the function gets one default argument from react, a props object containing a list of props given to the component.\n// To enable the use of props in our Component, we have to give our function a parameter(props). This parameter can be named anything you want, but props is the name most commonly use. \nconst Header = (props) => { // an arrow func expression\n    //console.log(props)\n    return ( \n        // if your are returning just JSX, you can use an implicit return\n        <header>\n        {/* To place the value of the props into the JXS inside the h1 and span, replacing the static text.To access the title and totaPlayers properties of the props obj use use dot notation just as you do this with any object literal in JS.\n        To display the content we use a JXS expression, a JXS expression is sourranded by curly braces.\n        props are \"read only\" (or immutable), which means that a component can only read the props given to it, never change them. The (parent) component higher in the tree owns and controls the property values. \n         */}\n            <h1>{ props.title }</h1>\n            <span className=\"stats\">Players: { props.totalPlayers\n} </span>\n        </header>\n    );\n    // including parentheses in JXS in optional\n}\n\n\nexport default Header;","import React from 'react';\n//import { render } from '@testing-library/react';\n\n/*\n    They are two ways to create a Component in React, a function and a class.\n    They are two ways that data gets handle in react, props ans state.\n\n    Functional Component \nWhen we create a component using a function this style is called stateless functional components. As the name implies, these component written as functions do not humble state. These components are only receiving input through props and rendering UI. \nFunctional Components just take in props and return JXS.\n\n    Component as a Class\nClass components offer a more powerful way to build components because they're the only type of components that let you use state.\nWe use a class component just like a functional component by including its JXS tag wherever you want to display it. \n\n#Classes need to access props with this.props. In class components, props are not are not accessed through arguments like they are in functional components. Props are a property of the component itself. So, this refers to the component instance.\n\nWhat is State?\nState itself is a regular JavaScript Object with properties that define the pieces of data that change.\n\nIn React, \"state\" is the data you want to track in your app. State is what allows you to create components that are dynamic and interactive, and it's the only data that changes over time.\nState is what keeps your UI in Sync with your data.\n\nWhen do you use a class versus a function?\n\nIf a component is only receiving input through props and rendering UI, it's best to use a function or a stateless functional component. Functions are little bit easier to write, understand, and read.\n\nWhen you want to add state, that's when you use a class component. However, you can also create stateless components as classes, there is nothing wrong with this approach, one benefit of this approach if you ever need to convert the component from stateless to stateful, you'll already have a class defined for it.  \n\n*/\n/* Functional Component\n\nconst Counter = (props) => {\n    return (\n        <div className=\"counter\">\n            <button className=\"counter-action decrement\">-</button>\n            <span className=\"counter-score\">{props.score}</span>\n            <button className=\"counter-action increment\">+</button>\n        </div>\n    );\n}*/\n// Class Component\n//class Counter extends Component {\n    /*\n        in JS classes, the extends keyword is used to create a subclass, or a child of another class.\n        The only method we need to define in a class component is called render.\n    */\n    //constructor() {\n        /* since state is an object, we create and initialize state within a class inside the constructor method.\n        Inside the constructor, I'll call super in order to call the constructor of the component class that we're extending. And this need to be done before we can use the \"this\" keyword within the constructor.\n\n        To initialize our component state, write this.state and set equal to an object. You must name this object state, otherwise this will not work.\n        You access state in a similar way to how you access props. \n\n        Another way to initialize state is directly inside a class definition, using a class property. You omit the constructor method and super all together, and reference the state property directly. You don't need to write it as this.state just state, and set equal to the object.\n        state = {\n            score:0\n        }\n        This class properties syntax is a feature of JavaScript that's currently not support by all browsers.\n\n        State is local to a component, meaning a component can maintain is own state, unlike props which are read-only.\n        */\n        //super() \n        //this.state = {\n            /*Since state is data that changes overtime we first name to set an initial state or the state of the component whe it fist mount*/\n            // This state in our counter is going to be the score we want to display for each player.\n\n            // To make our counter interactive we need to be able to triger changes to the data in state. The score changes when the user clicks the plus or minus button. First, let's create the function or event handler that update our state using React's built-in set state method. \n            // Whenever the score gets updated React will re-render our component and the change will be visible in our UI. \n            // In class components, a common pattern is to create event handlers as a method on the class. \n            //score: 0\n        //};\n    //}\n    //increamentScore = () =>  { // the name has not special meaning in React\n        //console.log(\"Hi, from inside increament score!\");\n        /*\n        In React, state is never modified directly. The only way React allows you to update a component's state is by using its built-in setState() method.\n        this.setState() let's React knows that state has changed, and that it should re-render and make changes to the component, base on the change in state.\n        You pass setState an object that contains the part of the state you wanna update, and the value you want to update it to. \n\n                Bind Event Handlers to Components\n        When you create a class component that extends from React.Component, any custom methods you create are not bound to the component by default. You need to bind your custom methods, so that this refers to the component instance. \n        They are several way to bind thisContext in React. \n        1. A common way is to call bind in the render method \n        Each counter component that gets mounted into the dom is an instance of the counter class.\n        In the button's onClick event, I'll call the JavaScript bind method on this.increamentScore and pass it the desired context via this. \n        this.increamentScore.bind(this)\n\n        2. The other common way to bind event handlers is with an arrow function.\n        So in my button, I'll pass an arrow function to the onClick event that calls this.increamentScore(onClick={() => this.increamentScore()) We don't need to bind this, that's because arrow functions use what's called a lexical this binding which means that it automatically bind them to the scope in which the are defined. \n        Inside the render method this refers to the counter component instance. The arrow function is enclosed inside the render method, so it takes on the same context. And the this value inside it will properly point to the counter component instance.\n\n        3. The most common way to define a event handler in React is with an arrow function. Arrow functions are automatically bond to the scope in which they are defined. So, if we rewrite the incrementScore method as an arrow function, the function gets bound to the component instance. The arrow function is enclosed inside the counter class, so the context is the component instance. Now we don't need to worry about binding it in the onClick event or in the constructor. We can simply reference and call the function in the onClick event with this.increamentScore make sure there is not parenthenses at the end.\n         */\n        /*\n            Communicating Between Components\n            A child component passes information back up to its ancestor(parent) thr a callback function. The callback will allow you to communicate events and changes in your data upwards, while data continue to flow downwards. \n        */\n        // this.setState(prevState => {\n        //     return {\n        //         score: prevState.score + 1,\n        //     }\n        // }); \n    //}\n\n    /*\n    This way we are mutating or altering the state object directly\n    decrementScore = () => {\n        this.setState({\n            score: this.state.score -1,\n        });\n    }\n    */\n    // This way is more reliable cause the callback function is garanteed to fired after the update is applied and rendered out to the DOM. To make the callback func more concise you could omit the return keyword and curly braces, by wrapping the body the function in parenthenses. \n    // decrementScore = () => {\n    //     this.setState(prevState => {\n    //         return {\n    //             score: prevState.score -1,\n    //         };\n    //     });\n        /*\n            Update State Based on Previous State\n            Whenever you need to update state based on previous state, you shouldn't rely on this.state to calculate the next state. State updates may be asynchronous, so it may not always lead to the component re-rendering with new data, and could cause state inconsistency. setState() accepts a callback function that produces state based on the previous state in a more reliable way. \n        */\n    //}\n    \n    \n        /*\n        render() {\n            The render method in a class component is a function of not just props but props and state. In other words, if either props or state changes, React executes the render method to update what gets display to the user.  \n         */\n        const Counter = (props) => {\n        let index = props.index;\n        return (\n            <div className=\"counter\">\n            {/* React events are similar to JavaScript events except that they are written inline and named using camelCase.\n            In the increament button, we'll specify the event we are listening for, onClick.(This event is specific to React, so you must name it onClick)\n            You pass React events JXS expressions, using curly braces and the event handler that will get called when the specified event happens. We don't use parentheses to all increamentScore like we usually do to call functions or methods in JavaScript. We are only passing a reference to the method. Adding parentheses will call increamentScore and make it run right when the component mounts, or gets displayed on the page, which we don't want. We want React to call increamentScore only when the onClick event is fired.\n             */}\n                <button className=\"counter-action decrement\" onClick={() => props.changeScore(index, -1) }>-</button>\n                <span className=\"counter-score\">{ props.score }</span>\n                <button className=\"counter-action increment\" onClick={()=> props.changeScore(index, 1)}>+</button>\n            </div> \n        );\n}\n\nexport default Counter; ","import React from 'react';\nimport Counter from './Counter';\n\nconst Player = (props) => {\n    \n    return (\n        <div className=\"player\">\n            <span className=\"player-name\">\n                <button className=\"remove-player\" onClick={ () => props.removePlayer(props.id)}>âœ–</button>\n                {props.name}\n            </span>\n\n            <Counter \n            score={props.score}\n            index={props.index}\n            changeScore={props.changeScore}\n            /> \n            {/* \n            Composition is when a component contains others components.\n            A component is a small reusable chunk of code that is usually responsible for rendering one piece of the user interface.\n            */}\n            {/* I'll give the child counter component a prop (of score), the prop can be named anything you want but to be consistent the with prop pass to the player component I named it score.\n            I'll pass the score prompt down to the counter with props.score.\n            Now, we can use the score prop by passing the counter function the parameter props and replacing the static score with curly braces and props.score.\n            Each component in your UI should be responsible for one thing only, and shouldn't contain extra code to handles other things.\n            In other words, each component addresses a specific concern.\n            */}\n        </div>\n    );\n}\n\nexport default Player;","import React, {Component} from 'react';\nimport '../App.css';\nimport Header from './Header';\nimport Player from './Player';\n\nclass App extends Component { //make App a stateful component\n  /*\n    Types of State\n  There are two main types of state:\n  1) Application State\n  Application State is the main state we typically think about. Data that is available to the entire application.\n\n  2) Component State\n  State that is specific to a component and not shared outside of the component.\n  (Local Component)\n  Ex. the state of the Counter component\n  */\n  state = {\n    players: [\n      {\n        name: \"Luz\",\n        score:0,\n        id: 1 //this create a unique key manually\n    },\n    {\n        name: \"George\",\n        score:0,\n        id: 2 //this create a unique key manually\n    },\n    {\n        name: \"Louis\",\n        score:0,\n        id: 3 //this create a unique key manually\n    },\n    {\n        name: \"Smith\",\n        score:0,\n        id: 4 //this create a unique key manually\n    }\n    ]\n  }\n  handleScoreChange = (index, delta) => {\n    //delta is the variation of a function\n    //the index param will determine the player whose score would change\n    debugger\n\n      this.setState(prevState => {\n        debugger\n        return {\n          score: prevState.players[index].score += delta,\n        }\n      });\n      //console.log(\"index \" + index, \"delta \" + delta)\n  }\n\n  handleRemovePlayer = (id) => {\n    // the func takes an id param for the player to remove from state\n    this.setState(prevState => {\n      // To the setState, we pass an object containing the prop to update\n      // We should never modify or mutate state directly, in order to remove a player from the players array on state, we need to produce a new array that no longer contains the player object we want to remove.\n      return {\n        players: prevState.players.filter((player) => {\n          return player.id !== id; // This return all the players excepts for the one we want to remove.\n        } )\n      }\n        \n      \n      \n    });\n\n  }\n  render() {\n    return (\n      <div className=\"scoreboard\">\n      {/* const arrayOfPlayers = props.initialPlayers; */}\n          <Header\n                  title=\"scoreboard\"\n                  totalPlayers={this.state.players.length}//Number of players\n              />\n              {/* Props \n                  Every React component and element can receive a list of attributes called properties (or props). Props are a core concept in React because it's how you get data into a component.Props pass data from a parent component down to a child component.\n                  You pass props to a component via the component's JXS tag at the place where is used. You can give a prop any name tha you want.\n                  Anytime you pass a value other than string, like a number or variable, you place it btw curly braces so that it gets evaluted as a JXS expression.\n                  The javaScript we write btw curly braces needs to be an expession or something that returns a value\n                  Prop Tips\n                  1. When a component has more than one prop, you'll often see them written on separate lines and indented.\n                  2. You can omit the value of a prop when it's explicitly true\n                  3. Use double quotes (\") when writing props. HTML attributes commonly use double quotes instead of single, so props mirror this convention\n              */}\n              {/* player list */}\n              \n              {//Every JavaScript expression written inside JXS needs to be place inside curly braces. So the JXS is able to evalute the expression\n                this.state.players.map( (player, index) => //this an implicit return omitting the return keyword and curly braces\n                  <Player \n                      name={player.name} \n                      score={player.score}\n                      id={player.id}\n                      key={player.id.toString()} \n                      index={index}\n                      changeScore={this.handleScoreChange}//this callback will run at later time thr some interaction with a child\n                      removePlayer={this.handleRemovePlayer}\n                      /*\n                      A key is a unique identifier that gives React a way to quickly and realibly identify an element in the list. It should be unique and should not be reused.(using indexes for keys is not recommended if the order of items may change. This can negatively impact performance and may cause issues with component state. )\n  \n                      The React docs recommend that we pass a string as the key value. So, to convert the id to string, we can call the toString() method on the player.id.\n  \n                      Not all React elements need a key prop. Pass a key prop anytime you're creating elements by itering over an array of items that will be rearranged, added or deleted in your UI. The key will help React identify which items were changed, added or removed from the DOM.\n                       */\n                      />\n                      /* Since player is the parent of counter, it's going to define the props for both a player's name and score. */\n              )}\n      </div>\n    );\n  }\n  \n}\nexport default App;\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom'; //react-dom is a module needed to render our application to the DOM. \nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\n/*const players = [\n  {\n      name: \"Luz\",\n      score: 45,\n      id: 1 //this create a unique key manually\n  },\n  {\n      name: \"George\",\n      score: 65,\n      id: 2 //this create a unique key manually\n  },\n  {\n      name: \"Louis\",\n      score: 75,\n      id: 3 //this create a unique key manually\n  },\n  {\n      name: \"Smith\",\n      score: 95,\n      id: 4 //this create a unique key manually\n  }\n]\n*/\nReactDOM.render(\n    <App />\n    ,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}